<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leveldb on Wiesen&#39;s Blog</title>
    <link>https://wiesen.github.io/tags/leveldb/</link>
    <description>Recent content in Leveldb on Wiesen&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 28 Jan 2017 21:31:20 +0800</lastBuildDate>
    
	<atom:link href="https://wiesen.github.io/tags/leveldb/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leveldb: Log</title>
      <link>https://wiesen.github.io/post/leveldb-storage-log/</link>
      <pubDate>Sat, 28 Jan 2017 21:31:20 +0800</pubDate>
      
      <guid>https://wiesen.github.io/post/leveldb-storage-log/</guid>
      <description>Leveldb 存储主要分为 SSTable（磁盘） 和 MemTable（内存，包括 MemTable 和 Immutable MemTable），此外还有一些辅助文件:Manifest, Log, Current。
本篇 blog 主要分析 Log：log 在 Leveldb 中的作用，一条log 在内存中的形式是什么，以怎样的方式被组织。
Log (db/log_format.h&amp;amp;cc,db/log_writer.h&amp;amp;.cc,db/log_reader.h&amp;amp;.cc) Introduction 日志（logging）分两种：
 诊断日志（diagnostic log）：即log4j、glog、log4cxx等常用日志库提供的日志功能 交易日志（transaction log）：即数据库的 write-ahead log、文件系统的journaling等，用于记录状态变更，通过 replay log 可以逐步恢复每一次修改之后的状态。  LevelDb 中的 log 是后者，主要作用是系统故障时进行数据恢复。**利用 WAL（write-ahead log），当故障时 Memtable 中的数据没来得及 Dump 成 SSTable 文件，LevelDB 可根据 log 文件恢复内存数据，保持数据（data和metadata）的持久性。
Format log record 以 block 为单位组织（32k）。写日志时，一致性考虑，并没有以 block 为单位写，而是每次更新均对 log 文件进行 IO，根据 WriteOption::sync 决定是否做强制 sync。读取时以 block 为单位做 IO 以及校验。log 的写入是顺序写，读取只会在启动时发生，不会是性能的瓶颈。
Log entry header 包含三个字段，checksum 是对“类型”和“数据”字段的校验码，为了避免处理不完整或者是被破坏的数据，当 leveldb 读取记录数据时候会对数据进行校验，如果 checksum 相同则说明数据完整无破坏，可以继续后续流程。length 表示 payload 长度，type 字段则指出了每条 log record 和 log block 之间的结构关系，主要有五种类型：ZERO/FULL/FIRST/MIDDLE/LAST，具体结构关系如上图所示。</description>
    </item>
    
    <item>
      <title>Leveldb: Block Cache</title>
      <link>https://wiesen.github.io/post/leveldb-cache/</link>
      <pubDate>Wed, 25 Jan 2017 21:31:20 +0800</pubDate>
      
      <guid>https://wiesen.github.io/post/leveldb-cache/</guid>
      <description>Block Cache (util/cache.cc)：
 Introduction
Cache 的目的：减少磁盘IO，加快 CURD 速度。
leveldb 中的 cache 分为 Table Cache 和 Block Cache 两种，其中 Table Cache 中缓存的是 sstable 的索引数据，Block Cache 缓存的是 Block 数据（可选打开）。
leveldb 中支持用户自己实现 block cache 逻辑，作为 option 传入。默认使用的是内部实现的 LRU。
 基于简单以及效率考虑，leveldb 中实现了一个简单的 hash table（LRUHandle），采用定长数组存放 node，链表解决 hash 冲突。每次 insert 后，如果 node 数量大于数组的容量（期望短的冲突链表长度），就将容量扩大2倍，做一次 rehash； LRU 的逻辑由 LRUCache 控制， insert 和 lookup 时更新链表即可； 由于 levelDB 为多线程，每个线程访问 cache 时都会对 cache 加锁。为了保证多线程安全并且减少锁开销，又将 LRUCache 再做 shard（ShardedLRUCache）。  整体来看：ShardedLRUCache 内部有 16 个 LRUCache（定长），查找 Key 时根据 key 的高四位进行 hash 索引，然后在相应的 LRUCache 中进行查找或更新。当 LRUCache 使用率大于总容量后, 根据 LRU 淘汰 key.</description>
    </item>
    
    <item>
      <title>Leveldb: Storage MemTable</title>
      <link>https://wiesen.github.io/post/leveldb-storage-memtable/</link>
      <pubDate>Tue, 20 Dec 2016 21:31:20 +0800</pubDate>
      
      <guid>https://wiesen.github.io/post/leveldb-storage-memtable/</guid>
      <description>Leveldb 存储主要分为 SSTable（磁盘） 和 MemTable（内存，包括 MemTable 和 Immutable MemTable），此外还有一些辅助文件:Manifest, Log, Current。
本篇 blog 主要分析 Memtable：Leveldb一条记录在内存中的形式是什么，记录以怎样的方式被组织。
Memtable (db/skiplist.h,db/memtable.h &amp;amp; memtable.cc)  Introduction MemTable 是 leveldb 的 kv 数据在内存中的存储结构。当 Memtable 写入的数据占用内存到达指定大小 (Options.write_buffer_size)，则自动转换为 Immutable Memtable（只读），同时生成新的 Memtable 供写操作写入新数据。后台的 compact 进程会负责将 immutable memtable dump to disk 生成 sstable。
通过 Memtable 和 Immutable Memtable，Leveldb 可在持久化到磁盘上的同时保持对外服务可用。这种特性是由 Leveldb 的适用场景催生的：Append 写。
Structure &amp;amp; Operation memtable key 的组成参照 Leveldb: Basic Settings。memtable 存储同一 key 的多个版本的数据。KeyComparator 首先按照递增顺序比较 user key，然后安装递减顺序比较sequence number，这两个足以唯一确定一条 entry。</description>
    </item>
    
    <item>
      <title>Leveldb: Basic Settings</title>
      <link>https://wiesen.github.io/post/leveldb-basic-concept/</link>
      <pubDate>Mon, 19 Dec 2016 21:31:20 +0800</pubDate>
      
      <guid>https://wiesen.github.io/post/leveldb-basic-concept/</guid>
      <description>（待完善……）
 Slice(include/leveldb/slice.h)
为操作数据的方便，将数据和长度包装成 Slice 使用，直接操控指针以避免不必要的数据拷贝
class Slice { … private: const char* data_; size_t size_; };  Option(include/leveldb/option.h)
leveldb 中启动时的一些配置，通过 Option 传入，get/put/delete 时，也有相应的 ReadOption/WriteOption。
 Env(include/leveldb/env.h util/evn_posix.h)
考虑到移植以及灵活性，leveldb 将系统相关的处理（文件/进程/时间之类）抽象成 Env，用户可以自己实现相应的接口，作为 Option 传入。默认使用自带的实现。
 varint(util/coding.h)
leveldb 采用了 protocalbuffer 里使用的变长整形编码方法，节省空间。
 ValueType(db/dbformat.h)
leveldb更新（put/delete）某个key时不会操控到db中的数据，每次操作都是直接新插入一份kv数据，具体的数据合并和清除由后台的compact完成。
所以，每次 put 都会添加一份 KV 数据，即使该 key 已经存在；而 delete 等同于 put 空的 value。为了区分 live 数据和已删除的 mock 数据，leveldb 使用 ValueType 来标识：
enum ValueType { kTypeDeletion = 0x0, kTypeValue = 0x1 };  SequenceNumber(db/dbformat.</description>
    </item>
    
    <item>
      <title>Leveldb: Introduction</title>
      <link>https://wiesen.github.io/post/leveldb-introduction/</link>
      <pubDate>Mon, 28 Nov 2016 21:31:20 +0800</pubDate>
      
      <guid>https://wiesen.github.io/post/leveldb-introduction/</guid>
      <description>看了不少 blog 分析 leveldb，但很少看到有人从设计原因和策略上进行总结。所以这个系列对 leveldb 的实现做一点设计分析，争取将内部实现逻辑串联起来，至于源码注释之类的网上一扒拉就有很多啦。
Introduction Leveldb 库提供持久层 kv 存储，其中 keys 和values 可以是任意字节数组。目前有 C++，golang 的实现。
作者 Jeff Dean, Sanjay Ghemawat 同时也是设计实现 BigTable 的作者。在 BigTable 中有两个关键部分：master server 和 tablet server。
 master server 负责存储 meta-data，并且调度管理 tablet server； tablet server 负责存储具体数据，并且响应读写操作。  Leveldb 可视为 BigTable 中 tablet server 的简化实现。
Features, Limitations, Performance 详见 leveldb homepage
How to use 详见 leveldb 使用文档
Background 冯诺依曼体系结构的计算机系统主要为两点：存储 + 计算。数据库即为存储方面，依赖于存储硬件特性。
当前磁盘物理结构特性导致 (磁头寻道，旋转延迟)：随机读写慢，连续读写快，相差三个数量级。内存和 SSD 同样表现，只不过原因是：连续读写可预判，因此会被优化 (相差量级也没磁盘那么大)。</description>
    </item>
    
  </channel>
</rss>