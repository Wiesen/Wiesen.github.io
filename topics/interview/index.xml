<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Interview on Wiesen&#39;s Blog</title>
    <link>http://wiesen.github.io/topics/interview/index.xml</link>
    <description>Recent content in Interview on Wiesen&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <atom:link href="http://wiesen.github.io/topics/interview/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>2018年实习面试总结</title>
      <link>http://wiesen.github.io/post/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 15 Feb 2017 21:31:33 +0800</pubDate>
      
      <guid>http://wiesen.github.io/post/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</guid>
      <description>

&lt;h2 id=&#34;百度上海-商务搜索商品推广部门&#34;&gt;百度上海（商务搜索商品推广部门）&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一面&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自我介绍+项目经历（10+分钟）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;基础知识&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义一个类的析构函数为虚函数的目的是什么？&lt;/li&gt;
&lt;li&gt;如果一个类不是作为基类，那么定义其析构函数为虚函数有什么问题？&lt;/li&gt;
&lt;li&gt;C++是以虚函数来实现多态，C如何实现多态（&lt;strong&gt;使用了哪种设计模式&lt;/strong&gt;）？（函数指针参数，定义参数类型和返回值类型）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;类的静态数据成员有什么特点？（内存分配及声明周期，从属于实例还是类）&lt;/li&gt;
&lt;li&gt;静态成员函数有什么特点？（从属于实例还是对象，访问限制）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编程（&lt;strong&gt;动手编码前讲清楚自己的思路&lt;/strong&gt;）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;给定一棵普通二叉树且每个结点含一个int值，然后给定int target值，打印出所有从根结点到叶子结点等于给定 target 值的路径。（递归回溯）&lt;/li&gt;
&lt;li&gt;单向无环链表倒数第k个结点。（k可能小于等于0）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开放题（&lt;strong&gt;常考海量数据问题，一般解决办法为：hash，partition，归并，B+树&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;问题：给定 10G 个数，只有 2G 内存，找出中位数。&lt;/p&gt;

&lt;p&gt;解：&lt;strong&gt;先 hash 分桶（如5个）进行粗粒度排序&lt;/strong&gt;，然后读取 4G~6G 的数据入内存&lt;strong&gt;进行划分 partition&lt;/strong&gt;，找出中位数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二面&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自我介绍+项目经历（30分钟）&lt;/p&gt;

&lt;p&gt;期间被问到交通系统出现死锁怎么办，没答出来。后来仔细想想其实是在考察&lt;strong&gt;反应能力、应变能力和知识迁移能力&lt;/strong&gt;，间接地考察OS中的调度问题和死锁问题。&lt;/p&gt;

&lt;p&gt;调度算法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;分为抢占式和非抢占式。可抢占式调度可有效减少等待时间和响应时间，但会带来较大的其他管理开销，使得吞吐量等的性能指标比不可抢占式调度要低&lt;/li&gt;
&lt;li&gt;常见的调度算法包括：先来先服务（FCFS，first come first serve），最短作业优先（SJF，shortest job first），时间片轮转（RR，round robin），最高响应比优先（HRRF，hightest response ratio first）
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;死锁：&lt;br /&gt;
- 定义：两个或多个进程无限地等待一个事件，而该事件只能由这些等待进程之一产生
- 原因：互斥，占有并等待，非抢占，循环等待
- 死锁处理办法：死锁预防，死锁避免，死锁检测和恢复，死锁忽略（认为死锁不可能在系统内发生）
    - 死锁预防：确保上述4个必要条件中至少一个不成立（副作用是低设备使用率和系统吞吐率 ）
    - 死锁避免：动态地检测资源分配状态以确保循环等待条件不可能成立（前提：需要事先了解进程使用资源的情况）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C++基础知识&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C++虚函数的作用什么？&lt;/li&gt;
&lt;li&gt;C++如何实现虚函数？&lt;/li&gt;
&lt;li&gt;构造函数和析构函数可以是虚函数吗？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编程&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;求无序数组中的 TOP K 个元素

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一个教训：做题目前一定要先认真审题&lt;/strong&gt;，后续回想起来自己审错题目了，输出的是前k小的元素&lt;/li&gt;
&lt;li&gt;另外做题阐述思路时没有必要马上说出所谓的最优解，&lt;strong&gt;重要的是对问题的分析能力&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/trapping-rain-water/&#34;&gt;https://leetcode.com/problems/trapping-rain-water/&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;第二道题一开始没理解面试官的意思，反复讲了10分钟，最后面试官没辙了给我发了个题图……我想了十多分钟后面试官表示时间不够了让我讲思路就够了【蒟蒻&amp;hellip;&lt;/li&gt;
&lt;li&gt;我一开始想的方法是左右检索非零的栅，然后取min，对中间的栅做一个类似于俄罗斯方块的消除操作（比min小的可以储水，比min大的则减去min），如何反复，直到左右相等则完成&lt;/li&gt;
&lt;li&gt;最后面试官说这个思路有点问题，然后告知这是leetcode上的题目，存在O(N)的解法，自己回去看看&lt;/li&gt;
&lt;li&gt;具体就是，将问题转化为每个 bar（array[i]）能trap多少水，然后将所有的加起来即可。而对于每个 array[i] 能trap多少水取决于其左右两边（不要求相邻）bar height的较小值与array[i]的差值，亦即是：&lt;code&gt;volume[i] = [min(left[i], right[i]) - array[i]] * 1&lt;/code&gt;（1为bar的宽度）&lt;/li&gt;
&lt;li&gt;在上述思路下，分别从左到右和从右到左遍历 array 生成 left 和 right 数组。然后再遍历一次 array 计算 volume 即可。当然这种方法还能继续优化，用两个指针分别从左右开始扫（类似快速排序里 partition 的扫描），可以做到单次遍历。&lt;/li&gt;
&lt;li&gt;看了不少blog，了解到这个方法算是一种常见的技巧，从两边各扫描一次得到我们需要维护的变量，&lt;strong&gt;通常适用于当前元素需要两边元素来决定的问题&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;阿里云-分布式存储部门&#34;&gt;阿里云（分布式存储部门）&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一面&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自我介绍&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;介绍一个你最了解的项目（注意说的时候别说自己半懂不懂的给自己挖坑）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目代码量多少&lt;/li&gt;
&lt;li&gt;这个项目你如果一直做的话，大概需要多长时间，为什么需要这么长时间（解释自己遇到的问题、原因和解决办法）&lt;/li&gt;
&lt;li&gt;解释一下 raft 协议的内容，怎么保证数据一致性，为什么需要 leader election 这个步骤&lt;/li&gt;
&lt;li&gt;之后我说 election timer 定时器必须足够随机，这里给自己挖坑了，被追问怎么才算足够随机、为什么、怎么确定随机数值&lt;/li&gt;
&lt;li&gt;你还读过什么关于分布式的论文&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;基础知识&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客套：你计算机里面哪门课学的比较好（注意别给自己挖坑）&lt;/li&gt;
&lt;li&gt;OS：进程和线程的区别&lt;/li&gt;
&lt;li&gt;网络：TCP和UDP的区别&lt;/li&gt;
&lt;li&gt;C/C++：struct结构体在C/C++之中的区别是什么&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;聊天&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;平时喜欢做什么&lt;/li&gt;
&lt;li&gt;看什么书（APUE/UNP/算法/C/C++&amp;hellip;）&lt;/li&gt;
&lt;li&gt;本科/研究生时在同学当中你属于什么类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;网易互娱-平台开发服务器方向&#34;&gt;网易互娱（平台开发服务器方向）&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一面（三个面试官同时面，视频只能看到自己看不到别人，跟受审一样）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自我介绍&lt;/p&gt;

&lt;p&gt;问我是不是主要是做Linux开发，我说是，成功挖坟&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Linux&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;给定一个目录，计算该目录下所有.c文件的行数，使用 Linux shell 完成（一次暴击重伤）：cat dir/*.c | wc -l&lt;/li&gt;
&lt;li&gt;如何查看一个文件被哪些进程打开了（二次濒临死亡）：isof&lt;/li&gt;
&lt;li&gt;大端小端是什么&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C/C++&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;static 的含义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const int *p 和 int* const p&lt;/code&gt; 的区别&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char *p = &amp;quot;hello&amp;quot;, char p[] = &amp;quot;hello&amp;quot;&lt;/code&gt;，sizeof的值分别是多少&lt;/li&gt;
&lt;li&gt;堆和栈的区别&lt;/li&gt;
&lt;li&gt;C/C++ 函数中的变长参数是如何实现的&lt;/li&gt;
&lt;li&gt;strcpy 函数有什么问题，这个问题会导致怎样的结果&lt;/li&gt;
&lt;li&gt;STL 中的 map 是用什么实现的，map 和 hash_map 的区别是什么，根据什么情况选择使用哪种map&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;算法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;求一个整数的平方根（三次暴击完全gg）：二分即可&lt;/li&gt;
&lt;li&gt;给定一个文件，长度是未知的，要求一次遍历，然后求随便一行被输出的概率（完全没理解题意，四次暴击鞭尸）：蓄水池采样&lt;/li&gt;
&lt;li&gt;n个元素求前k小个元素：时间复杂度答错了，最好的&lt;strong&gt;时间复杂度应该是O(N)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;基础&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TCP和UDP的区别&lt;/li&gt;
&lt;li&gt;解释一下TCP三次握手，为什么不能二次或者四次

&lt;ul&gt;
&lt;li&gt;这个问题的本质是：信道不可靠, 但是通信双发需要就某个问题达成一致.

&lt;ul&gt;
&lt;li&gt;而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值.&lt;/li&gt;
&lt;li&gt;所以三次握手不是TCP本身的要求, 而是为了满足&amp;rdquo;在不可靠信道上可靠地传输信息&amp;rdquo;这一需求所导致的.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;三次握手的目的：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误（解决“网络中存在延迟的重复分组”的问题）

&lt;ol&gt;
&lt;li&gt;client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段&lt;/li&gt;
&lt;li&gt;但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。&lt;/li&gt;
&lt;li&gt;由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。&lt;/li&gt;
&lt;li&gt;server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;解释一下滑动窗口的原理，什么时候会滑动&lt;/li&gt;
&lt;li&gt;TCP有什么定时器

&lt;ol&gt;
&lt;li&gt;重传定时器&lt;/li&gt;
&lt;li&gt;坚持定四期&lt;/li&gt;
&lt;li&gt;保活定时器&lt;/li&gt;
&lt;li&gt;2MSL定时器&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;完结，一行代码没写出来，最后说了句“如果通过了三个工作日内会通知”，翻译过来意思就是“赶紧去投别的吧咱们这你gg了”&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;阿里云-飞天&#34;&gt;阿里云（飞天）&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一面&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;项目&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;解释一下 raft 协议的内容，怎么保证数据一致性：其中没长脑子，又说了 election timer 定时器必须足够随机，再次挖坑&lt;/li&gt;
&lt;li&gt;自动驾驶系统项目是什么&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;算法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将BST原地变换为有序单链表：对指针操作不够熟练，导致递归返回赋值时链表断掉&lt;/li&gt;
&lt;li&gt;面试官好人，代码错了还是把我过了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二面&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;算法（直接gg）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个job由多个task组成，每个task运行一定时间，task之间存在依赖关系。如：A: 2，B: 1，C: 10，D: 8，其中，A-&amp;gt;B，A-&amp;gt;D。求运行完所有task最少需要多少时间。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;网易互联网-分布式存储&#34;&gt;网易互联网（分布式存储）&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一面&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;项目&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;讲一下 raft 协议的基本组成，每个机器有哪几种状态&lt;/li&gt;
&lt;li&gt;raft 协议如何保证数据一致性，比如一个 leader 崩溃重启后，raft 如何应对

&lt;ol&gt;
&lt;li&gt;举例子能力不够，逻辑性不够强，并且语言组织不够简练&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;实现 key/value storage system 时，为什么读也要经过 raft

&lt;ol&gt;
&lt;li&gt;一开始没完全理解面试官的问题，&lt;strong&gt;导致沟通出现问题&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后面自己理解出现偏差&lt;/strong&gt;，对 storage system 的原理不够深入了解，并且与面试官吵了起来；&lt;/li&gt;
&lt;li&gt;raft 的目的是要保证数据一致性，读并不修改数据一致性，因此&lt;strong&gt;读只需要从 leader 中读取即可&lt;/strong&gt;（哪怕这个 leader 是 network partition），但不能从 follower 中读取（因为 follower 的数据还未 catch up）&lt;/li&gt;
&lt;li&gt;就算是并发情况下也不会有问题，由于写必须经过 raft 来完成，因此后续的读不会读出未经过 raft 的写，不会出现读写不一致问题&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;你有哪些项目是与人合作完成的

&lt;ol&gt;
&lt;li&gt;当时心态已经失衡了，因此只是简单提了一下其余项目的分工和自己的职责&lt;/li&gt;
&lt;li&gt;应该简洁阐述项目来源和介绍，然后阐述自己的职责，以及如何组织、分工和协调，自己又完成了什么内容，分工协调时遇到了什么问题，最后如何解决的&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;基础&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;C 与 C++ 的区别是什么&lt;/strong&gt;，以你平时写代码的经验来讲讲&lt;/li&gt;
&lt;li&gt;STL 的算法你常用什么，讲一下 sort 函数的实现（gg，刚好没看过，不过觉得自己说的差不多一样了）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;腾讯-qq后台&#34;&gt;腾讯（QQ后台）&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一面&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基础&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;N 从 0 开始，判断第 N bit 是不是 1：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;太紧张，写了很多冗余的语句（除法和求余），并且当发生错误时设置了错误标志但没有返回值！&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;sizeof()&lt;/code&gt; 返回的是字节byte数！而不是位bit数！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// N从0开始，判断第N bit是不是1
int erron = 0;
bool NthBitIsOne(unsigned long str[k], int N) {
    if (N &amp;gt; k * sizeof(unsigned long) * 8 || N &amp;lt; 0) {
        erron = 1;
        return false; // !谨记返回
    }
    return str[N/(sizeof(unsigned long) * 8) + ((unsigned long)1 &amp;lt;&amp;lt; (N%(sizeof(unsigned long) * 8)))];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指针操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 32位，小端地址
char b[8] = {0};
char *a = b;
int *c = (int*)b;
short *s = (short*)b;
*s = 1;
cout &amp;lt;&amp;lt; *a &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; *c &amp;lt;&amp;lt; endl;
*s = -1;
cout &amp;lt;&amp;lt; *a &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; *c &amp;lt;&amp;lt; endl;
*s = 256;
cout &amp;lt;&amp;lt; *a &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; *c &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串常量数组大小计算&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char *m[] = {&amp;quot;abc&amp;quot;, &amp;quot;abcdfe&amp;quot;};
cout &amp;lt;&amp;lt; sizeof(m) &amp;lt;&amp;lt; endl;
char (*n)[] = {&amp;quot;abcsfd&amp;quot;, &amp;quot;abcda&amp;quot;};
cout &amp;lt;&amp;lt; sizeof(n) &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;频繁调用malloc会发生什么问题？&lt;/strong&gt;当32系统上的物理内存小于4g呢？如果只申请而不写呢？：不懂，回答错误&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当主机物理内存能满足最小要求时，&lt;strong&gt;只调用malloc而不写入，会被编译器或者系统优化掉，永远只获取某一页的地址&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;mmap()有什么用？&lt;/strong&gt;：不够熟悉，没怎么用过，回答错误&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;算法设计&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;QQ后台登录，登录量为60w/minute，一共有10亿（1G）个用户，将5分钟内重复登录的用户拒绝其登录请求，其中用户ID无法完全放入内存，设计一种数据结构

&lt;ol&gt;
&lt;li&gt;5分钟内最大用户登录数量为：60*5=300w，可以放入内存&lt;/li&gt;
&lt;li&gt;利用 LRU cache 存储5分钟内登录的用户ID：map（rb-tree in O(logN) search，hashtable in O(1) search） + double linked list（in O(1) update）

&lt;ol&gt;
&lt;li&gt;双向链表用于存储数据结点，并且它是按照结点最近被使用的时间来存储的&lt;/li&gt;
&lt;li&gt;使用哈希表可以让我们在O(1)的时间找到想要访问的结点， 或者返回未找到&lt;/li&gt;
&lt;li&gt;当未找到结点时，即可将新的数据结点放至双向链表头部&lt;/li&gt;
&lt;li&gt;当找到节点时，需要将数据结点进行更新，此时将该结点从链表中取出（此时双向链表的优势体现了），然后放至链表头部&lt;/li&gt;
&lt;li&gt;当未找到结点且我们的Cache满了， 需要替换掉的就是双向链表中最后的那个结点(不是尾结点，头尾结点不存储实际内容)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二面&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;OS：64位的OS只有3g物理内存，一个进程想要申请4g的内存可以吗？

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;只申请不写入：不分配实际内存，仅分配虚拟内存地址&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;写入：通过 swap() 实现&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;网络：讲一下从浏览器中输入 www.qq.com 后，浏览器负责做了什么，以及整个工作流程

&lt;ol&gt;
&lt;li&gt;DNS-HTTP-TCP-IP-PPP&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;HTTP：如果我在1分钟后再次输入同一个网址，浏览器会做什么？&lt;strong&gt;除了缓存呢？&lt;/strong&gt;

&lt;ol&gt;
&lt;li&gt;？&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;TCP：HTTP要求close session时，TCP如何断开链接？画出四次分手的流程图和状态转换

&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;算法：一个单执行流操作系统，每秒执行一次CheckTimer()，其中有一个注册定时器函数Register()可用于向系统注册定时函数，一个获取当前时间的函数Gettime()，设计一种数据结构和算法以最低的时间复杂度实现该过程，不考虑函数的执行时间

&lt;ol&gt;
&lt;li&gt;编码前要做好需求和情景分析：&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;编码时注意细节：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据结构：堆&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;阿里-搜索&#34;&gt;阿里（搜索）&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一面&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;C/C++：类和对象的区别？指针和引用的区别？

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;语言组织不要乱！&lt;/strong&gt;想好再说！不要重复着同样一句话和支支吾吾！&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指针和引用的内存占用区别&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;OS：做过嵌入式的话了解OS吗？OS是如何管理内存的？一个进程的空间地址是如何组织的？进程调用&lt;code&gt;malloc()&lt;/code&gt;申请很大的空间会怎样？如果进程对申请到的空间进行写入，OS是如何为进程分配物理内存的？进程和线程的区别是什么？

&lt;ol&gt;
&lt;li&gt;分段分页内存管理：分段是为了向进程提供虚拟的连续内存地址；分页是为了向进程提供庞大的虚拟内存空间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;触发缺页异常&lt;/strong&gt;（没有回答出），OS进入内核态，然后为进程分配物理内存页，把线性地址前若干位作为页号，余下位作为页内偏移地址，寻址物理内存&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;写代码：

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;char arr = &amp;quot;AAA&amp;quot;&lt;/code&gt;；后面的字符串占多少空间&lt;/li&gt;
&lt;li&gt;实现 &lt;code&gt;char* strcpy(char* dest, char* src)&lt;/code&gt;，不能调用库函数&lt;/li&gt;
&lt;li&gt;给定两个有序链表，把他们合并为一个有序列表；把&lt;code&gt;main&lt;/code&gt;函数补充完整；手动link太麻烦，给你两个数组把它们转换为链表；用顺序的方式把数组转换为链表

&lt;ol&gt;
&lt;li&gt;main：&lt;strong&gt;切记用&lt;code&gt;delete&lt;/code&gt;释放&lt;code&gt;new&lt;/code&gt;的空间！&lt;/strong&gt;（在面试官已经提示的情况下仍然出错）&lt;/li&gt;
&lt;li&gt;指针：更恰当的方式应当采用 RAII 智能指针！&lt;/li&gt;
&lt;li&gt;结构体：&lt;code&gt;struct LinkNode* next&lt;/code&gt;！；&lt;strong&gt;初始化方式&lt;/strong&gt;有4种，最简单的为 &lt;code&gt;LinkNode* head = new LinkNode{NULL, 0}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数：&lt;strong&gt;要抽象出通用功能！&lt;/strong&gt;别贪图方便复制无用代码！这是面试官的考察点！&lt;/li&gt;
&lt;li&gt;链表：链表创建应当采用可复用和可循环的数组！&lt;/li&gt;
&lt;li&gt;数组指针传参：数组指针会退化为普通指针，这时候要加一个数组长度参数：&lt;code&gt;len = sizeof(arr)/sizeof(int)&lt;/code&gt;！&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;项目&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二面&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;编程题&lt;strong&gt;（思路清楚逻辑清晰，一遍 coding 通过，而不是频繁修改已经敲进去的代码！！！）&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;实现 &lt;code&gt;char* strcpy(char* dest, char* src)&lt;/code&gt;，不能调用库函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char * strcpy(char * strDest,const char * strSrc) ｛
    assert((strDest!=NULL) &amp;amp;&amp;amp; (strSrc!=NULL));
    char *address = strDest;
    while ((*strDest++ = *strSrc++) != &#39;\0&#39;);
    return address;
｝
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;给定一个二叉树，找出所有有效路径中各节点&lt;strong&gt;相加总和&lt;/strong&gt;等于给定 目标值 的路径。注：一个有效的路径，指的是从根节点到叶节点的路径&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;给一个链表，然后我们要把这个链表中第m个节点到第n个节点的部分翻转。设： 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2 and n = 4,返回： 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL.注：1 ≤ m ≤ n ≤ length of list&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;项目经验&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;raft：

&lt;ol&gt;
&lt;li&gt;这个项目主要是做什么，为什么要做这个&lt;/li&gt;
&lt;li&gt;解释一下 raft 一致性协议&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;有没有别的关于比赛和论文的成果和学习到的东西可以讲讲：&lt;/li&gt;
&lt;li&gt;用三个词总结一下你自己，以及举个具体例子体现出来：&lt;/li&gt;
&lt;li&gt;讲一下这个网联式自动驾驶系统项目，以及你在这个项目里面承担什么发挥了什么作用：

&lt;ol&gt;
&lt;li&gt;python 用在了什么地方&lt;/li&gt;
&lt;li&gt;ROS 是什么&lt;/li&gt;
&lt;li&gt;服务端是用 java 写的对吧&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;基础&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;程序、进程和线程的区别&lt;/li&gt;
&lt;li&gt;堆和栈的区别&lt;/li&gt;
&lt;li&gt;malloc 和 new 申请的内存在哪块地方&lt;/li&gt;
&lt;li&gt;关于虚拟内存你知道什么&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;kika-后台开发&#34;&gt;kika（后台开发）&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一面&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;架构&lt;strong&gt;（先梳理清楚需求分析、功能定义，确定核心问题点和技术点，再去决定采用何种方法和架构）&lt;/strong&gt;

&lt;ol&gt;
&lt;li&gt;流式处理系统：

&lt;ol&gt;
&lt;li&gt;关于语音和文本之间的匹配搜集问题&lt;/li&gt;
&lt;li&gt;log 应该如何组织和记录&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;语音标注系统：

&lt;ol&gt;
&lt;li&gt;问题：

&lt;ol&gt;
&lt;li&gt;语音标注系统是离线的，这个系统记录一些关于语料和文本的数据&lt;/li&gt;
&lt;li&gt;客户端（网页）请求某个日期或者某个用户的语料数据和文本数据&lt;/li&gt;
&lt;li&gt;客户端（网页）可以对这些语料数据和文本数据做一个判断，标注的内容是一段文本，表示正确的识别文本应该是什么，从而反馈出来哪些语料识别错误了&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端（网页）可以是多人同时标注，并且需要网络失败问题&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;数据量为几个T&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;分析：

&lt;ol&gt;
&lt;li&gt;首先，如何高效的查询数据，查询条件包括时间，标注人&lt;/li&gt;
&lt;li&gt;其次修改数据，如何高效的修改数据中的存储，看是错误还是正确&lt;/li&gt;
&lt;li&gt;另外，考虑到响应要快+大量数据，NoSQL中建议用KeyValue数据，redis不太合适，用Hbase是最理想的选择&lt;/li&gt;
&lt;li&gt;然后查询的时候，如何用正确的数据之类的，在用hbase的时候，要考虑查询的维度与rowKey之间的设计方案&lt;/li&gt;
&lt;li&gt;rowKey: 语料Key, column = {UserId: {timeStamp: , data}}&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;会不会前端？&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;基础

&lt;ol&gt;
&lt;li&gt;父类有公有函数A和私有函数B，子类继承自父类，有公有函数C，通过子类访问函数A，会得到怎样的结果？访问函数B呢？

&lt;ol&gt;
&lt;li&gt;什么继承机制？公有继承还是私有继承还是保护继承？&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;虚函数和纯虚函数的区别&lt;/li&gt;
&lt;li&gt;为什么父类的析构函数必须是虚函数&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;实习

&lt;ol&gt;
&lt;li&gt;你在百度具体负责什么内容

&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;是否了解整个系统架构

&lt;ol&gt;
&lt;li&gt;了解，但核心代码无法接触&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;为什么不留在百度

&lt;ol&gt;
&lt;li&gt;在百度由于权限问题所能接触到的业务和架构有限，每天只接触自己负责的一小部分&lt;/li&gt;
&lt;li&gt;希望能够发挥自己的特长，并且学习不同的技术&lt;/li&gt;
&lt;li&gt;想感受不同公司的文化氛围，体验一下大公司和创业公司之间是怎样的&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;在百度是有人带你吗&lt;/li&gt;
&lt;li&gt;你想做工程还是做策略&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二面&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;编程题

&lt;ol&gt;
&lt;li&gt;实现 &lt;code&gt;int2str(int num)&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;sprintf(buf, &amp;quot;%d&amp;quot;, num)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;int的正数和负数表达范围不一致：-2^31~2^31-1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;reverse()&lt;/code&gt; 是 algorithm 库函数！&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;实习

&lt;ol&gt;
&lt;li&gt;你在百度具体负责什么内容：&lt;/li&gt;
&lt;li&gt;为什么选择kika：

&lt;ol&gt;
&lt;li&gt;首先我觉得kika的切入方向和目标用户在国内公司里来说是很特别的，包括说通过匹配用户输入意图来进行商业推广，以及以国外社交圈作为自己的扩展手段，我认为这些都是很好的，比较感兴趣&lt;/li&gt;
&lt;li&gt;其次我希望能够在公司里发挥一个比当前岗位更大的作用，扩展自己的业务能力和技术能力&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三面：主管&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;你们部门主要方向和目标是什么？实习的主要内容是什么？

&lt;ol&gt;
&lt;li&gt;结构化商品信息，精确广告投放和匹配&lt;/li&gt;
&lt;li&gt;物料质量控制&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;为什么这种乱绑定的物料会影响到广告投放性能指标？广告主是如何做到搜什么都能匹配到这个商品？

&lt;ol&gt;
&lt;li&gt;通配，无法做到精确的地域匹配和商品匹配&lt;/li&gt;
&lt;li&gt;买大量的广告词&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;你有没有考虑过为什么要做这件事情，广告主他的确可以买很多词并且这在流程上是合法的，你们凭什么要对他们的商品进行下线处理？

&lt;ol&gt;
&lt;li&gt;我们会为广告主推荐一些关键词，但广告主不同意或者表示怀疑就会自买广告词，这时候我们会通过一个线上广告投放log分析出这些问题物料&lt;/li&gt;
&lt;li&gt;我们并非强制对他们的物料进行下线处理，而是交由PM与他们进行协商&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;你们怎么说服广告主可以对他们的商品进行下线处理？

&lt;ol&gt;
&lt;li&gt;通过数据提供足够说服力，表明通过精确匹配可以降低他们的广告投放成本，并且提高点击率&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;四面：CTO&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;讲一讲当前自动驾驶的技术路线&lt;/li&gt;
&lt;li&gt;我看你做了关于激光雷达室内定位，你讲一讲当前室内定位的难点在哪

&lt;ol&gt;
&lt;li&gt;基于信号测距的室内定位：需要部署基站，需要自建地图&lt;/li&gt;
&lt;li&gt;基于激光雷达等扫描匹配的室内定位：设备成本高，数据量大&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;滴滴-java后台开发&#34;&gt;滴滴（java后台开发）&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一面&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二面&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三面&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;微软-stca&#34;&gt;微软（STCA）&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;一面&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>