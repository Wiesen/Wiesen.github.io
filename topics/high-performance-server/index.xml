<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>High Performance Server on Wiesen&#39;s Blog</title>
    <link>http://wiesen.github.io/topics/high-performance-server/index.xml</link>
    <description>Recent content in High Performance Server on Wiesen&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <atom:link href="http://wiesen.github.io/topics/high-performance-server/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>I/O Event Handling Design Patterns</title>
      <link>http://wiesen.github.io/post/IO-Event-Handling-Design-Patterns/</link>
      <pubDate>Thu, 24 Nov 2016 21:31:20 +0800</pubDate>
      
      <guid>http://wiesen.github.io/post/IO-Event-Handling-Design-Patterns/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;System I/O can be blocking, or non-blocking synchronous, or non-blocking asynchronous:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Blocking I/O means that the calling system does not return control to the caller until the operation is finished&lt;/li&gt;
&lt;li&gt;a non-blocking synchronous call returns control to the caller immediately&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I/O multiplexing mechanisms rely on an event demultiplexor: dispatches I/O events from a limited number of sources to the appropriate read/write event handlers.&lt;/p&gt;

&lt;p&gt;There are two non-blocking I/O multiplexing mechanisms: reactor &amp;amp;&amp;amp; proactor.&lt;/p&gt;

&lt;h2 id=&#34;mechanism&#34;&gt;Mechanism&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Reactor&lt;/p&gt;

&lt;p&gt;In the Reactor pattern, the event demultiplexor waits for events that indicate when a file descriptor or socket is ready for a read or write operation.&lt;/p&gt;

&lt;p&gt;Structure:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Request Event Dispatcher (&lt;strong&gt;synchronous&lt;/strong&gt; event demultiplexer): uses an event loop to block on all resources, and dispatches resources from the demultiplexer to the associated event handler&lt;/li&gt;
&lt;li&gt;Request Event Handler (user handler): performs the actual I/O operation, handles data, , declares renewed interest in I/O events, and returns control to the dispatcher&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Benific:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;separates application specific code from the reactor implementation&lt;/li&gt;
&lt;li&gt;allows for simple coarse-grain concurrency while not adding the complexity of multiple threads to the system&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Limitations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;more difficult to debug than a procedural pattern due to the inverted flow of control&lt;/li&gt;
&lt;li&gt;by only calling event handlers synchronously, it limits maximum concurrency, especially on symmetric multiprocessing hardware&lt;/li&gt;
&lt;li&gt;The scalability of the reactor pattern is limited by event handler and demultiplexer
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Proactor&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7vij5d.com1.z0.glb.clouddn.com/Proactor.png&#34; alt=&#34;proactor&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In the Proactor pattern, the initiator (event demultiplexor) initiates asynchronous I/O operations. The I/O operation itself is &lt;strong&gt;performed by OS&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A completion handler is called after the asynchronous part has terminated. The proactor pattern can be considered to be an &lt;strong&gt;asynchronous variant&lt;/strong&gt; of the synchronous reactor pattern.&lt;/p&gt;

&lt;p&gt;The implementation of this classic asynchronous pattern is based on an asynchronous OS-level API, which is called it &amp;ldquo;system-level&amp;rdquo; or &amp;ldquo;true&amp;rdquo; async.&lt;/p&gt;

&lt;p&gt;Structure:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Proactive Initiator : initiates asynchronous I/O operations&lt;/li&gt;
&lt;li&gt;Completion Event Dispatcher (event demultiplexor): waits for events that indicate the completion of the I/O operation, and forwards those events to the appropriate handlers&lt;/li&gt;
&lt;li&gt;Completion Event Handler (user handler): handles the data from user defined buffer, starts a new asynchronous operation, and returns control to the dispatcher&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;emulated-proactor-implementation&#34;&gt;Emulated Proactor Implementation&lt;/h2&gt;

&lt;p&gt;A solution to the challenge of designing a portable framework for the Proactor and Reactor I/O patterns: transform a Reactor demultiplexor I/O solution to an emulated async I/O by moving read/write operations from event handlers inside the demultiplexor (this is &amp;ldquo;emulated async&amp;rdquo; approach).&lt;/p&gt;

&lt;p&gt;We simply shifted responsibilities between different actors. By adding functionality to the demultiplexor I/O pattern, we were able to convert the Reactor pattern to a Proactor pattern.&lt;/p&gt;

&lt;p&gt;Structure:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dispatcher (&lt;strong&gt;asynchronous&lt;/strong&gt; event demultiplexer): performs a non-blocking I/O operation and on completion calls the appropriate handler&lt;/li&gt;
&lt;li&gt;Event Handler (user handler): handles data from the user-defined buffer, declares new interes, then returns control to the dispatcher&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Referenceï¼š&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://www.artima.com/articles/io_design_patternsP.html&#34;&gt;Comparing Two High-Performance I/O Design Patterns&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Reactor_pattern&#34;&gt;Reactor pattern&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Proactor_pattern&#34;&gt;Proactor pattern&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>