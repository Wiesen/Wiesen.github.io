<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Database on Wiesen&#39;s Blog</title>
    <link>http://wiesen.github.io/topics/database/</link>
    <description>Recent content in Database on Wiesen&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Mon, 28 Nov 2016 21:31:20 +0800</lastBuildDate>
    <atom:link href="http://wiesen.github.io/topics/database/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Leveldb: Introduction</title>
      <link>http://wiesen.github.io/post/leveldb-Introduction/</link>
      <pubDate>Mon, 28 Nov 2016 21:31:20 +0800</pubDate>
      
      <guid>http://wiesen.github.io/post/leveldb-Introduction/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Leveldb 库提供持久层 kv 存储，其中 keys 和values 可以是任意字节数组。目前有 C++，golang 的实现。&lt;/p&gt;

&lt;p&gt;作者 Jeff Dean, Sanjay Ghemawat 同时也是设计实现 BigTable 的作者。在 BigTable 中有两个关键部分：master server 和 tablet server。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;master server 负责存储 meta-data，并且调度管理 tablet server；&lt;/li&gt;
&lt;li&gt;tablet server 负责存储具体数据，并且响应读写操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Leveldb 可视为 BigTable 中 tablet server 的简化实现。&lt;/p&gt;

&lt;h2 id=&#34;features-limitations-performance&#34;&gt;Features, Limitations, Performance&lt;/h2&gt;

&lt;p&gt;详见 &lt;a href=&#34;https://github.com/google/leveldb&#34;&gt;leveldb homepage&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;how-to-use&#34;&gt;How to use&lt;/h2&gt;

&lt;p&gt;详见 &lt;a href=&#34;https://github.com/google/leveldb/blob/master/doc/index.html&#34;&gt;leveldb 使用文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;

&lt;p&gt;冯诺依曼体系结构的计算机系统主要为两点：&lt;strong&gt;存储 + 计算&lt;/strong&gt;。数据库即为存储方面，依赖于存储硬件特性。&lt;/p&gt;

&lt;p&gt;当前磁盘物理结构特性导致 (磁头寻道，旋转延迟)：&lt;strong&gt;随机读写慢，连续读写快&lt;/strong&gt;，相差三个数量级。内存和 SSD 同样表现，只不过原因是：连续读写可预判，因此会被优化 (相差量级也没磁盘那么大)。&lt;/p&gt;

&lt;p&gt;上述说明：基于目前这样的硬件特性，我们设计存储系统时要&lt;strong&gt;尽量避免随机读写，设计为顺序读写&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;然而，读操作和写操作是相互矛盾的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为了优化读操作，最好是将相关的数据写入相邻的块，以维护顺序读，而这造成了随机写；&lt;/li&gt;
&lt;li&gt;为了优化写操作，最好是所有的写都是 Append，也就是顺序写，而这造成了随机读。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;题外话：常见的优化读操作性能的设计有：二分、hash、B+ 树等。这些方法使用各种查找结构来组织数据，有效提升读操作性能(最少提供了O(logN))，但是增加了随机写操作，大大降低了写操作性能。&lt;/p&gt;

&lt;p&gt;因此，如果一个业务&lt;strong&gt;对写操作的吞吐量十分敏感，或者写操作数量远远大于读操作&lt;/strong&gt;，那么应该采取的措施是：&lt;strong&gt;优化写操作，也就是尽量将写操作设计为 Append&lt;/strong&gt;，从而尽可能地减少寻道，以达到磁盘理论写入速度最大值。&lt;/p&gt;

&lt;p&gt;这个策略常用于日志或者堆文件这种业务场景中，因为它们是完全顺序的（包括读写），所以可以提供很好的写操作性能。&lt;/p&gt;

&lt;h2 id=&#34;leveldb-core-idea&#34;&gt;Leveldb Core Idea&lt;/h2&gt;

&lt;p&gt;以 &lt;strong&gt;LSM(Log Structured Merge) Tree&lt;/strong&gt;组织数据达到顺序写，辅以 &lt;strong&gt;Bloom Filter&lt;/strong&gt; 和 &lt;strong&gt;Shard LRU cache&lt;/strong&gt; 优化随机读操作。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Log-structured_merge-tree&#34;&gt;&lt;strong&gt;LSM tree&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;关于论文的部分分析详见&lt;a href=&#34;https://blog.acolyer.org/2014/11/26/the-log-structured-merge-tree-lsm-tree/&#34;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;div style=&#34;text-align: center&#34;&gt;
&lt;img src=&#34;http://7vij5d.com1.z0.glb.clouddn.com/memtable.png&#34; width=&#34;500&#34;/&gt; &lt;img src=&#34;http://7vij5d.com1.z0.glb.clouddn.com/compaction.png&#34; width=&#34;500&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;LSM tree 针对&lt;strong&gt;写入速度瓶颈问题&lt;/strong&gt;而提出，其基本思想是：&lt;strong&gt;将随机写转换为顺序写，交换读和写的随机 IO&lt;/strong&gt;，数据更新仅以 Append 操作进行，并保存为有序文件 SSTable (Sorted String Table)到磁盘中（read only），每个文件保存一段时间内的数据更新。&lt;/p&gt;

&lt;p&gt;LSM Tree 的主要措施有:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对更新进行批量 &amp;amp; 延时处理 (超过大小阈值后将内存中的数据 dump 到磁盘中)：减少寻道，提高写操作性能；&lt;/li&gt;
&lt;li&gt;周期性地利用归并排序对磁盘文件执行合并操作 (compaction)：移除已删除和冗余数据，减少文件个数，保证读操作性能；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Bloom_filter&#34;&gt;&lt;strong&gt;Bloom Filter&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;div style=&#34;text-align: center&#34;&gt;
&lt;img src=&#34;http://7vij5d.com1.z0.glb.clouddn.com/bloomfilter.png&#34; width=&#34;550&#34;/&gt;
&lt;/div&gt;
    

&lt;p&gt;由于 LSM Tree 会产生大量文件，因此 LevelDb 利用 bloomfilter 来避免大量的读操作。&lt;/p&gt;

&lt;p&gt;bloomfilter 以概率性算法高效检索一个 key 是否在一个 SSTable (核心为 hash，若判断为不存在则必定不存在，若判断为存在则可能不存在)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_Recently_Used_.28LRU.29&#34;&gt;Shard LRU Cache&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;leveldb 中的 cache 分为 Table Cache 和 Block Cache 两种，其中 Table Cache 中缓存的是 sstable 的索引数据，Block Cache 缓存的是 Block 数据（可选打开）&lt;/p&gt;

&lt;p&gt;由于 levelDB 为多线程，每个线程访问缓冲区时都会对缓冲区加锁。为了保证多线程安全并且减少锁开销，leveldb 定义了一个 SharedLRUCache。&lt;/p&gt;

&lt;p&gt;ShardedLRUCache 内部有 16 个 LRUCache，查找 Key 时根据 key 的高四位进行 hash 索引，然后在相应的 LRUCache 中进行查找或更新。当 LRUCache 使用率大于总容量后, 根据 LRU 淘汰 key.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;overall-architecture&#34;&gt;Overall Architecture&lt;/h2&gt;

&lt;div style=&#34;text-align: center&#34;&gt;
&lt;img src=&#34;http://7vij5d.com1.z0.glb.clouddn.com/leveldb-architecture.png&#34; width=&#34;500&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;Leveldb 存储主要分为 SSTable 和 MemTable，前者为不可变且存储于持久设备上，后者位于内存上并且可变。其中有两个 MemTable，一个为当前写入 MemTable，另一个为等待持久化的 Immutable MemTable。此外还有一些辅助文件，后面详述。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Write Operation&lt;/strong&gt;：当用户需要插入一条 kv 到 Leveldb 中时，首先会被存储到 log 中 &lt;strong&gt;(Write Ahead Log, WAL, 保证数据持久性)&lt;/strong&gt;；然后插入到 MemTable 中；当 MemTable 达到一定大小后会转化为 read-only Immutable MemTable，并且创建一个新的 MemTable；同时开启一个新的后台线程将 Immutable MemTable 的内容 dump 到磁盘中，创建一个新的 SSTable；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deletion Operation&lt;/strong&gt;：在 Leveldb 中视为特殊的 Write operation，写入一个 deletion marker。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Read Operation&lt;/strong&gt;：当 leveldb 收到一个 Get 请求时，首先会在 MemTable 进行查找；然后在 Immutable MemTable 查找；最后在 SSTable 中查找（从 level 0 到 higher level），直到匹配到一个 kv item 或者为 NULL。&lt;/p&gt;

&lt;h2 id=&#34;file-layout&#34;&gt;File Layout&lt;/h2&gt;

&lt;p&gt;详见 &lt;a href=&#34;https://github.com/google/leveldb/blob/master/doc/impl.html&#34;&gt;leveldb 实现文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;source-code-structure&#34;&gt;Source Code Structure&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;leveldb-1.4.0  
|
+--- port           &amp;lt;=== 提供各个平台的基本接口
|
+--- util           &amp;lt;=== 提供一些通用工具类
|
+--- helpers
|      |
|      +--- memenv  &amp;lt;=== Env的一个具体实现(Env是leveldb封装的运行环境)
|
+--- table          &amp;lt;=== 磁盘数据结构
|
+--- db             &amp;lt;=== db的所有实现
|
+--- doc
|     |
|     +--- table_format.txt   &amp;lt;=== 磁盘文件数据结构说明
|     |
|     +--- log_format.txt     &amp;lt;=== 日志文件（用于宕机恢复未刷盘的数据）数据结构说明
|     |
|     +--- impl.html          &amp;lt;=== 一些实现
|     |
|     +--- index.html         &amp;lt;=== 使用说明
|     |
|     +--- bench.html         &amp;lt;=== 测试数据
|
+--- include
     |
     +--- leveldb           &amp;lt;=== 所有头文件
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>