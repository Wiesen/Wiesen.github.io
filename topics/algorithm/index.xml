<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Wiesen&#39;s Blog</title>
    <link>http://wiesen.github.io/topics/algorithm/</link>
    <description>Recent content in Algorithm on Wiesen&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Fri, 15 Apr 2016 21:31:33 +0800</lastBuildDate>
    <atom:link href="http://wiesen.github.io/topics/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>微软2016校招在线笔试题解</title>
      <link>http://wiesen.github.io/post/%E5%BE%AE%E8%BD%AF2016%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Fri, 15 Apr 2016 21:31:33 +0800</pubDate>
      
      <guid>http://wiesen.github.io/post/%E5%BE%AE%E8%BD%AF2016%E6%A0%A1%E6%8B%9B%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E9%A2%98%E8%A7%A3/</guid>
      <description>

&lt;p&gt;微软2016校招在线笔试题解
题目地址：&lt;a href=&#34;http://hihocoder.com/contest/mstest2016april1/problems&#34;&gt;mstest2016april1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;感受：一定要理解好题意，注意细节。另外微软特别喜欢考察反向思维。&lt;/p&gt;

&lt;h2 id=&#34;a-font-size&#34;&gt;A. Font Size&lt;/h2&gt;

&lt;p&gt;选择一个最大字号刚好可以令页数不超过给定阈值P。&lt;/p&gt;

&lt;p&gt;逻辑理清即可。页由行组成，行由字符组成，其中字符为方形。需要注意的地方是：(1) 每段都从新的一行开始；(2) 每页至少显示一个字符。&lt;/p&gt;

&lt;p&gt;字号是整数，可以暴力求解遍历直到合适字号，单点时间复杂度为&lt;code&gt;O(10^6)&lt;/code&gt;，没有超过题目限制。但如果题目再卡紧点就有点危险了，所以更好的方法是利用二分查找，注意好边界条件即可。&lt;/p&gt;

&lt;p&gt;编码思路如下：&lt;/p&gt;

&lt;p&gt;1.确定字号最小值为1，最大值为 &lt;code&gt;min(W, H)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.求字号为中值 &lt;code&gt;m&lt;/code&gt; 时的页数：每段所占行数 &lt;code&gt;a[i]/(W/m)&lt;/code&gt;，对所有段所占行数求和，最后求所占页数 &lt;code&gt;total/(H/m)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;3.当所占页数大于等于阈值P，则&lt;code&gt;r=m&lt;/code&gt;，小于则&lt;code&gt;l=m+1&lt;/code&gt;，直到&lt;code&gt;l&amp;gt;=r&lt;/code&gt;。注意等于阈值P时并不代表已经找到解，字号可能还能增大。&lt;/p&gt;

&lt;p&gt;4.解为 &lt;code&gt;r-1&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;b-403-forbidden&#34;&gt;B. 403 Forbidden&lt;/h2&gt;

&lt;p&gt;题目的要求是进行 IP 地址匹配，返回最先（序号最小）匹配到的规则的动作，没有匹配的规则则返回 allow。&lt;/p&gt;

&lt;p&gt;一种方法是利用前缀树求解。建树方法: 在插入新规则 new 时，在该规则的前缀路径上（含等长）已有规则 old，意味着 old 屏蔽了new，直接丢弃新规则new。
由此，在匹配一个 IP 地址时，只需要返回前缀树上匹配这个 IP 地址的最长规则。&lt;/p&gt;

&lt;p&gt;建树时间复杂度为 &lt;code&gt;O(N)&lt;/code&gt;，匹配一次只需要常数时间，整体时间复杂度为 &lt;code&gt;O(min{N,M})&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;c-demo-day&#34;&gt;C. Demo Day&lt;/h2&gt;

&lt;p&gt;动态规划水题，起始位置为 (1,1)，动作为向下或向右，考虑好各个状态转移,并且注意边界特殊情况即可。时间复杂度为 &lt;code&gt;O(N*M)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;DP[i][j][k]&lt;/code&gt; 含义为：在第 i 行 第 j 列时，向 k 方向前进需要改变多少个格子 &lt;code&gt;(1&amp;lt;=i&amp;lt;=N, 1&amp;lt;=j&amp;lt;=M, k=right or down)&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DP[i][j][right] = min{DP[i][j-1][right], DP[i-1][j][down] + (i + 1 &amp;lt; n &amp;amp;&amp;amp; maze[i+1][j] != &#39;b&#39;)} + (maze[i][j] == &#39;b&#39;);
DP[i][j][down] = min{DP[i-1][j][down], DP[i][j-1][right] + (j + 1 &amp;lt; m &amp;amp;&amp;amp; maze[i][j+1] != &#39;b&#39;)} + (maze[i][j] == &#39;b&#39;);
DP[i-1][j][k] 仅在 i - 1 &amp;gt; 0 时存在，同理 DP[i][j-1][k] 仅在 j - 1 &amp;gt; 0 时存在。
最后结果：ans = min{DP[N][M][right], DP[N][M][down])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;d-building-in-sandbox&#34;&gt;D. Building in Sandbox&lt;/h2&gt;

&lt;p&gt;思路参考&lt;a href=&#34;https://www.zhihu.com/question/42406890/answer/94388263&#34;&gt;知乎&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;题目的初始条件是地面([1,1,0]~[100,100,0])已经摆满了方块。&lt;/p&gt;

&lt;p&gt;对于新添加的方块有下面两个要求：
1. 相邻性：必须与之前之前放置的立方体(包括地面)相邻；
2. 可达性：必须能够从空间外部在不穿过任何方块的前提下到达该方块，换言之就是不能处于封闭空间中。&lt;/p&gt;

&lt;p&gt;对于第一个要求每次添加时进行简单的逻辑判断即可。&lt;/p&gt;

&lt;p&gt;第二个要求根据一位答主的想法，由闭空间判断转换为开空间判断，就变成了图论里的简单题目了：先对外部空间做一个FloodFill；然后倒序判断方块 &lt;code&gt;i&lt;/code&gt; 是否与外部空间相邻；相邻的话就删除该方块，然后做FloodFill；一旦存在不相邻就是处于封闭空间中。&lt;/p&gt;

&lt;p&gt;不过该方法是离线判断，强制在线可参考另一个&lt;a href=&#34;https://www.zhihu.com/question/42406890/answer/94480532&#34;&gt;回答&lt;/a&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;阅读参考&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/42406890&#34;&gt;https://www.zhihu.com/question/42406890&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.gotit.sinaapp.com/&#34;&gt;http://www.gotit.sinaapp.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://yfwz100.github.io/articles/interv/microsoft-2016.html&#34;&gt;http://yfwz100.github.io/articles/interv/microsoft-2016.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>快速排序笔记</title>
      <link>http://wiesen.github.io/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 15 Mar 2016 21:31:20 +0800</pubDate>
      
      <guid>http://wiesen.github.io/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AC%94%E8%AE%B0/</guid>
      <description>

&lt;p&gt;快排最引人注目的特点是原地排序（只需要一个很小的辅助栈），且将长度为 &lt;em&gt;N&lt;/em&gt; 的数组排序所需的时间和 &lt;em&gt;NlgN&lt;/em&gt; 成正比。
而快排的主要缺点是非常脆弱，在实现时必须非常小心才能避免性能低下。&lt;/p&gt;

&lt;p&gt;同前述一致：以 C++ 实现,仅针对 vector 进行操作, 并且遵循 C++ 左闭右开的区间标准: [a,b)。&lt;/p&gt;

&lt;h2 id=&#34;基本算法&#34;&gt;基本算法&lt;/h2&gt;

&lt;p&gt;快排也是一种分治的排序算法，快排与归并排序是互补的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;归并排序将数组分成两个子数组分别排序，再将有序子数组归并以将整个数组排序，其递归调用发生在处理整个数组&lt;strong&gt;之前&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;而快排则是先确定 &lt;code&gt;key&lt;/code&gt; 的位置，而后当两个子数组都有序时则整个数组即有序，其递归调用发生在处理整个数组&lt;strong&gt;之后&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;快排的关键在划分，划分过程需要使得数组满足以下三个条件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于某个 &lt;code&gt;key&lt;/code&gt;，&lt;code&gt;a[key]&lt;/code&gt; 已经排定；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[low,key)&lt;/code&gt; 中所有元素都不大于 &lt;code&gt;a[key]&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[key,high)&lt;/code&gt; 中所有元素都不小于 &lt;code&gt;a[key]&lt;/code&gt;。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://7vij5d.com1.z0.glb.clouddn.com/quick.png&#34; alt=&#34;quick&#34; /&gt;&lt;/p&gt;

&lt;p&gt;据此，快排的基本思想是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;选取一个元素作为切分元素 &lt;code&gt;key&lt;/code&gt;，然后从数组左端开始向右扫描直到找到一个大于等于它的元素，再从数组右端开始向左扫描直到找到一个小于等于它的元素，而后交换它们的位置;&lt;/li&gt;
&lt;li&gt;如此继续，就可以保证左指针 &lt;code&gt;left&lt;/code&gt; 的左侧元素都不大于 &lt;code&gt;key&lt;/code&gt;，右指针 &lt;code&gt;right&lt;/code&gt; 的右侧都不小于 &lt;code&gt;key&lt;/code&gt;;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当左右指针相遇时 &lt;code&gt;（left &amp;gt;= right）&lt;/code&gt;，将切分元素 key 与左子数组最右元素（也就是 &lt;code&gt;right&lt;/code&gt; 最终停下的位置）交换然后返回划分位置 &lt;code&gt;right&lt;/code&gt; 即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int Partition(std::vector&amp;lt;T&amp;gt; &amp;amp;vec, int low, int high) {
    int left = low, right = high;
    while (true) {
        // Avoid subscript beging out of range
        while (vec[++left] &amp;lt; vec[low]) if (left == high - 1)break;
        while (vec[low] &amp;lt; vec[--right]) if (right == low)break;
        // Terminate the loop
        if (left &amp;gt;= right)break;
        std::swap(vec[left], vec[right]);
    }
    std::swap(vec[low], vec[right]);
    return right;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;快排中有若干细节问题值得注意，否则会导致实现错误或者性能下降:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;越界：这里遵循左闭右开原则 [a,b)，因此左侧不能访问最右元素（右侧可以访问最左元素），否则将会出现越界。本文在内循环中左指针的 break 处理上与右指针有所差异：&lt;code&gt;if (left == high - 1) break&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;随机性：快排是一个&lt;strong&gt;随机化&lt;/strong&gt;的算法，因此在排序前需将数组随机打乱，在 C++ 中使用    &lt;code&gt;std::random_shuffle&lt;/code&gt; 函数对数组进行处理。将数组随机化的原因是希望能够预测并依赖该算法的性能特点，后续本文阐述。&lt;/li&gt;
&lt;li&gt;循环：当左指针大于或等于右指针时终于划分&lt;code&gt;Partition()&lt;/code&gt;中的循环,最后将切分元素 &lt;code&gt;key&lt;/code&gt; 放入正确位置： &lt;code&gt;std::swap(vec[key], vec[right])&lt;/code&gt;。而事实上， &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 的位置正好一致或相邻。当一侧元素全部小于或大于 &lt;code&gt;key&lt;/code&gt; 时，则 &lt;code&gt;left == right&lt;/code&gt;，否则 &lt;code&gt;left - 1 == right&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;递归：当子数组为空或所含元素仅为1个时则无需再处理，在左闭右开区间 [a,b) 中即为 &lt;code&gt;b - a &amp;lt;= 1&lt;/code&gt;。否则继续处理，同时为了贯彻左闭右开原则，代码中的递归如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void NormalQuick(std::vector&amp;lt;T&amp;gt; &amp;amp;vec, int low, int high) {
    // Terminate the recursive
    if (high - low &amp;lt;= 1){
        Insertion(vec, low, high);
        return;
    }
    int nCut = Partition(vec, low, high);
    // Detail: Use range[low, high)
    NormalQuick(vec, low, nCut);
    NormalQuick(vec, nCut + 1, high);
｝
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;算法改进&#34;&gt;算法改进&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;切换到插入排序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;和大多数递归排序算法一样，改进快排性能的一个简单办法是在排序小树组时切换到插入排序，从而避免递归调用，并且对于小数组来说快排比插入排序慢。&lt;/p&gt;

&lt;p&gt;经验表明，在大多数情况下 &lt;code&gt;CUTOFF&lt;/code&gt; 取值 5~15 能够取得比较好的性能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (high - low &amp;lt;= CUTOFF) {
    Insertion(vec, low, high);
    return;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;三取样切分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;待补充&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;熵最优快排——三向切分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所谓的“熵最优”是指：对于任意分布的输入，最优的基于比较的排序算法平均所需的比较次数与三向切分快排平均所需的比较次数相比，处于常数因子范围之内。当然前提是需要将数组进行随机化。&lt;/p&gt;

&lt;p&gt;进一步使用信息论来解释快排性能可参考 Algs4 中的快排章节，Mackayd的&lt;a href=&#34;http://users.aims.ac.za/~mackay/sorting/sorting.html&#34;&gt;Heapsort, Quicksort, and Entropy&lt;/a&gt;。刘未鹏的&lt;a href=&#34;http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/&#34;&gt;数学之美番外篇：快排为什么那样快&lt;/a&gt;也值得一看，浅显易懂。&lt;/p&gt;

&lt;p&gt;三向切分快排的运行时间和输入的信息量的 &lt;em&gt;N&lt;/em&gt; 倍成正比。对于含有大量重复元素的数组，它将快排的排序时间从&lt;strong&gt;线性对数级&lt;/strong&gt;降低到&lt;strong&gt;线性级别&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;基本想法是将数组切分为三部分，分别对应小于、等于和大于切分元素的数组元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dijkstra 三向切分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Dijkstra 提出的“三向切分快速排序”极为简洁。这里的额外交换用于和切分元素&lt;strong&gt;不等&lt;/strong&gt;的元素。 其从左到右遍历数组一次：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;维护指针 &lt;code&gt;left&lt;/code&gt; 使得 &lt;code&gt;[low, left)&lt;/code&gt; 中的元素均小于 key；&lt;/li&gt;
&lt;li&gt;维护一个指针 &lt;code&gt;right&lt;/code&gt; 使得 &lt;code&gt;[right, high)&lt;/code&gt; 中的元素均大于 key；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nMid&lt;/code&gt; 使得 &lt;code&gt;[left, nMid)&lt;/code&gt; 中的元素均等于 key；&lt;/li&gt;
&lt;li&gt;余下 &lt;code&gt;[nMid, right)&lt;/code&gt; 中的元素尚未排定。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://7vij5d.com1.z0.glb.clouddn.com/3-wayquick.png&#34; alt=&#34;3wayquick&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void OptimalQuick(std::vector&amp;lt;T&amp;gt; &amp;amp;vec, int low, int high) {
    if (high - low &amp;lt;= CUTOFF){
        Insertion(vec, low, high);
        return;
    }
    int left = low, nMid = low + 1, right = high - 1;
    T key = vec[low];
    while (nMid &amp;lt;= right)
    {
        if (vec[nMid] &amp;lt; key){
            std::swap(vec[left], vec[nMid]);
            left++; nMid++;
        }
        else if (key &amp;lt; vec[nMid]){
            std::swap(vec[nMid], vec[right]);
            right--;
        }
        else nMid++;
    }
    OptimalQuick(vec, low, nMid);
    OptimalQuick(vec, right + 1, high);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;快速三向切分（J.Bently, D.McIlroy)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过将重复元素置于子数组两端，从而实现一个信息量最优的排序算法。该方法与上述方法是等价的，只是快速三向切分中的额外交换用于和切分元素&lt;strong&gt;相等&lt;/strong&gt;的元素。过程如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;维护指针 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt; 使得 &lt;code&gt;vec[low, p)&lt;/code&gt; 和 &lt;code&gt;vec[q, high)&lt;/code&gt; 中的元素都和 &lt;code&gt;key&lt;/code&gt; 相等;&lt;/li&gt;
&lt;li&gt;维护指针 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 使得 &lt;code&gt;vec[p, i)&lt;/code&gt; 中的元素小于 &lt;code&gt;key&lt;/code&gt; ，&lt;code&gt;vec[j, q)&lt;/code&gt; 中的元素大于 &lt;code&gt;key&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;在切分循环结束后将和 &lt;code&gt;key&lt;/code&gt; 相等的元素交换到正确的位置上。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://7vij5d.com1.z0.glb.clouddn.com/bmquick.png&#34; alt=&#34;quickX&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void QuickX(std::vector&amp;lt;T&amp;gt; &amp;amp;vec, int low, int high) {
    if (high - low &amp;lt;= CUTOFF){
        Insertion(vec, low, high);
        return;
    }

    int p = low, q = high, i = low, j = high;
    T key = vec[low];
    while (true){
        while (vec[++i] &amp;lt; key)if (i == high - 1)break;
        while (key &amp;lt; vec[--j])if (j == low)break;
        if (i == j &amp;amp;&amp;amp; key == vec[i]){
            std::swap(vec[++p], vec[i]);
        }
        if (i &amp;gt;= j)break;
        std::swap(vec[i], vec[j]);
        // exchange only when equal to key
        if(vec[i] == key)std::swap(vec[++p], vec[i]);
        if(vec[j] == key)std::swap(vec[--q], vec[j]);
    }
    // exchange to right position
    i = j + 1;
    while (p &amp;gt;= low)std::swap(vec[p--], vec[j--]);
    while (q &amp;lt; high)std::swap(vec[q++], vec[i++]);
    // recursive
    QuickX(vec, low, j + 1);
    QuickX(vec, i, high);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;Reference：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://algs4.cs.princeton.edu/home/&#34;&gt;Algs4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://users.aims.ac.za/~mackay/sorting/sorting.html&#34;&gt;Heapsort, Quicksort, and Entropy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/&#34;&gt;数学之美番外篇：快排为什么那样快&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>归并排序笔记</title>
      <link>http://wiesen.github.io/post/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 10 Mar 2016 21:24:46 +0800</pubDate>
      
      <guid>http://wiesen.github.io/post/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AC%94%E8%AE%B0/</guid>
      <description>

&lt;p&gt;归并排序是一种渐近最优的基于比较排序的算法, 意即: 其在最坏情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是~NlgN。其主要的优点是可以保证将任意长度为 N 的数组排序的时间复杂度为 O(NlgN); 其主要缺点是空间复杂度为 O(N)。&lt;/p&gt;

&lt;p&gt;这里均以 C++ 实现, 为了避免陷入到语言细节里所以仅针对 vector 进行操作, 并且遵循 C++ &lt;strong&gt;左闭右开&lt;/strong&gt;的区间标准: [a,b)。值得注意的是区间表示一致性这个细节对针对数组和搜索(如二分查找)的算法有着举足轻重的影响。&lt;/p&gt;

&lt;p&gt;至于倾向于 [a,b) 左闭右开区间表示的原因可参考&lt;a href=&#34;http://stackoverflow.com/questions/9963401/why-are-standard-iterator-ranges-begin-end-instead-of-begin-end&#34;&gt;链接&lt;/a&gt;。简单来说主要原因有二: 一是 end-begin 即可得到区间大小; 二是当区间退化为 0 时包含左界更加&amp;rdquo;natural&amp;rdquo;。&lt;/p&gt;

&lt;h1 id=&#34;自顶向下的归并排序&#34;&gt;自顶向下的归并排序&lt;/h1&gt;

&lt;p&gt;递归实现的归并排序是算法设计中&lt;strong&gt;分治思想&lt;/strong&gt;的典型应用。&lt;/p&gt;

&lt;p&gt;主要是两个函数: 由 &lt;code&gt;MergeSort()&lt;/code&gt; 负责递归调用, &lt;code&gt;Merge()&lt;/code&gt; 负责归并。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;优化一: 对小规模子数组使用插入排序&lt;/p&gt;

&lt;p&gt;递归会使小规模问题中方法的调度过于频繁, 而插入或者选择在小数组上比归并要快, 所以改进对小规模子数组的处理方法可以改进整个算法。根据经验, 使用插入处理小规模子数组(&amp;lt;15)可将归并的运行时间缩短10%~15%。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;优化二: 测试子数组是否有序&lt;/p&gt;

&lt;p&gt;添加一个判断条件: &lt;code&gt;if (a[mid] &amp;gt; a[mid+1])&lt;/code&gt; 再进行 &lt;code&gt;Merge()&lt;/code&gt; 操作, 否则数组已经是有序的。进行此优化可以令任意有序的子数组算法时间复杂度变为线性。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;优化三: 不将元素复制到辅助数组&lt;/p&gt;

&lt;p&gt;在递归调用的每个层次交换输入数组和辅助数组的角色, 可节省将数组元素复制到用于归并的辅助数组的时间(无法节省空间)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;class T&amp;gt;
void Merge(std::vector&amp;lt;T&amp;gt; &amp;amp;src, std::vector&amp;lt;T&amp;gt; &amp;amp;dest, int nHead, int nMid, int nEnd) {
    int nLeftIndex = nHead, nRightIndex = nMid;
    for (int i = nHead; i &amp;lt; nEnd; ++i){
        // Detail: Use range[nHead, nEnd)
        if (nLeftIndex &amp;gt;= nMid) dest[i] = src[nRightIndex++];
        else if (nRightIndex &amp;gt;= nEnd) dest[i] = src[nLeftIndex++];
        else if (src[nLeftIndex] &amp;lt; src[nRightIndex]) dest[i] = src[nLeftIndex++];
        else dest[i] = src[nRightIndex++];
    }
}

template&amp;lt;class T&amp;gt;
void MergeSort(std::vector&amp;lt;T&amp;gt; &amp;amp;src, std::vector&amp;lt;T&amp;gt; &amp;amp;dest, int nHead, int nEnd) {
    // if (nEnd - nHead &amp;lt;= 1) return; // Before optimizing
    // Optimization 1: Use InsertSort when small scale
    if (nEnd - nHead &amp;lt;= 15) {
        InsertSort(dest, nHead, nEnd);
        return;
    }
    int nMid = (nHead + nEnd) / 2;
    // Optimization 2: Avoid copying to auxiliary array
    MergeSort(dest, src, nHead, nMid);
    MergeSort(dest, src, nMid, nEnd);
    // Optimization 3: If the sub-array is sorted then skip merge
    if (src[nMid - 1] &amp;lt;= src[nMid]){
        std::copy(src.begin() + nHead, src.begin() + nEnd, dest.begin() + nHead);
    }
    else Merge(src, dest, nHead, nMid, nEnd);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;自底向上的归并排序&#34;&gt;自底向上的归并排序&lt;/h1&gt;

&lt;p&gt;实现归并排序的另一种方法是化递归为循环自底向上进行归并, 即先归并微型子数组, 然后再成对归并得到的子数组, 如此这般直至将整个数组归并在一起。该实现比递归方法代码量少, 但复杂度一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;class T&amp;gt;
void Merge(std::vector&amp;lt;T&amp;gt; &amp;amp;vec, int nHead, int nMid, int nEnd) {
    std::vector&amp;lt;T&amp;gt; tmp(vec);
    int nLeftIndex = nHead, nRightIndex = nMid;
    for (int i = nHead; i &amp;lt; nEnd; ++i){
        if (nLeftIndex &amp;gt;= nMid) vec[i] = tmp[nRightIndex++];
        else if (nRightIndex &amp;gt;= nEnd) vec[i] = tmp[nLeftIndex++];
        else if (tmp[nLeftIndex] &amp;lt; tmp[nRightIndex]) vec[i] = tmp[nLeftIndex++];
        else vec[i] = tmp[nRightIndex++];
    }
}

template&amp;lt;class T&amp;gt;
void MergeSortBU(std::vector&amp;lt;T&amp;gt; &amp;amp;vec, int nHead, int nEnd) {
    int nLength = nEnd - nHead;
    for (int sz = 1; sz &amp;lt; nLength; sz += sz){
        for (int i = nHead; i &amp;lt; nLength - sz; i = i + sz + sz){
            int nMin = nLength &amp;lt; i + sz + sz ? nLength : i + sz + sz;
            Merge(vec, i, i + sz, nMin);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;Reference:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Algorithms, 4th Edition&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/acgtyrant/Algorithm-and-Data-Structure/wiki&#34;&gt;https://github.com/acgtyrant/Algorithm-and-Data-Structure/wiki&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/9963401/why-are-standard-iterator-ranges-begin-end-instead-of-begin-end&#34;&gt;http://stackoverflow.com/questions/9963401/why-are-standard-iterator-ranges-begin-end-instead-of-begin-end&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>